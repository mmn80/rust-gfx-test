// This code is auto-generated by the shader processor.

#[allow(unused_imports)]
use rafx_framework::RafxResult;

#[allow(unused_imports)]
use rafx_framework::{
    DescriptorSetAllocator, DescriptorSetArc, DescriptorSetBindings, DescriptorSetInitializer,
    DescriptorSetWriter, DescriptorSetWriterContext, DynDescriptorSet, ImageViewResource,
    ResourceArc,
};

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct PositionsStd430 {
    pub pos: [[f32; 2]; 100], // +0 (size: 800)
} // 800 bytes

pub type PositionsBuffer = PositionsStd430;

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct VelocityStd430 {
    pub vel: [[f32; 2]; 100], // +0 (size: 800)
} // 800 bytes

pub type VelocityBuffer = VelocityStd430;

pub const POSITIONS_DESCRIPTOR_SET_INDEX: usize = 0;
pub const POSITIONS_DESCRIPTOR_BINDING_INDEX: usize = 0;
pub const VELOCITIES_DESCRIPTOR_SET_INDEX: usize = 0;
pub const VELOCITIES_DESCRIPTOR_BINDING_INDEX: usize = 1;

pub struct DescriptorSet0Args<'a> {
    pub positions: &'a PositionsBuffer,
    pub velocities: &'a VelocityBuffer,
}

impl<'a> DescriptorSetInitializer<'a> for DescriptorSet0Args<'a> {
    type Output = DescriptorSet0;

    fn create_dyn_descriptor_set(
        descriptor_set: DynDescriptorSet,
        args: Self,
    ) -> Self::Output {
        let mut descriptor = DescriptorSet0(descriptor_set);
        descriptor.set_args(args);
        descriptor
    }

    fn create_descriptor_set(
        descriptor_set_allocator: &mut DescriptorSetAllocator,
        descriptor_set: DynDescriptorSet,
        args: Self,
    ) -> RafxResult<DescriptorSetArc> {
        let mut descriptor = Self::create_dyn_descriptor_set(descriptor_set, args);
        descriptor.0.flush(descriptor_set_allocator)?;
        Ok(descriptor.0.descriptor_set().clone())
    }
}

impl<'a> DescriptorSetWriter<'a> for DescriptorSet0Args<'a> {
    fn write_to(
        descriptor_set: &mut DescriptorSetWriterContext,
        args: Self,
    ) {
        descriptor_set.set_buffer_data(POSITIONS_DESCRIPTOR_BINDING_INDEX as u32, args.positions);
        descriptor_set.set_buffer_data(VELOCITIES_DESCRIPTOR_BINDING_INDEX as u32, args.velocities);
    }
}

pub struct DescriptorSet0(pub DynDescriptorSet);

impl DescriptorSet0 {
    pub fn set_args_static(
        descriptor_set: &mut DynDescriptorSet,
        args: DescriptorSet0Args,
    ) {
        descriptor_set.set_buffer_data(POSITIONS_DESCRIPTOR_BINDING_INDEX as u32, args.positions);
        descriptor_set.set_buffer_data(VELOCITIES_DESCRIPTOR_BINDING_INDEX as u32, args.velocities);
    }

    pub fn set_args(
        &mut self,
        args: DescriptorSet0Args,
    ) {
        self.set_positions(args.positions);
        self.set_velocities(args.velocities);
    }

    pub fn set_positions(
        &mut self,
        positions: &PositionsBuffer,
    ) {
        self.0
            .set_buffer_data(POSITIONS_DESCRIPTOR_BINDING_INDEX as u32, positions);
    }

    pub fn set_velocities(
        &mut self,
        velocities: &VelocityBuffer,
    ) {
        self.0
            .set_buffer_data(VELOCITIES_DESCRIPTOR_BINDING_INDEX as u32, velocities);
    }

    pub fn flush(
        &mut self,
        descriptor_set_allocator: &mut DescriptorSetAllocator,
    ) -> RafxResult<()> {
        self.0.flush(descriptor_set_allocator)
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_struct_positions_std430() {
        assert_eq!(std::mem::size_of::<PositionsStd430>(), 800);
        assert_eq!(std::mem::size_of::<[[f32; 2]; 100]>(), 800);
        assert_eq!(std::mem::align_of::<[[f32; 2]; 100]>(), 4);
        assert_eq!(memoffset::offset_of!(PositionsStd430, pos), 0);
    }

    #[test]
    fn test_struct_velocity_std430() {
        assert_eq!(std::mem::size_of::<VelocityStd430>(), 800);
        assert_eq!(std::mem::size_of::<[[f32; 2]; 100]>(), 800);
        assert_eq!(std::mem::align_of::<[[f32; 2]; 100]>(), 4);
        assert_eq!(memoffset::offset_of!(VelocityStd430, vel), 0);
    }
}
